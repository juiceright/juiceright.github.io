<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Python on Juiceright</title>
    <link>https://juiceright.xyz/tags/python/</link>
    <description>Recent content in Python on Juiceright</description>
    <generator>Hugo -- 0.154.5</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Dec 2025 10:18:33 +0000</lastBuildDate>
    <atom:link href="https://juiceright.xyz/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【分子对接】2. 利用pymol下载蛋白质 脚本</title>
      <link>https://juiceright.xyz/old/posts/ysld_6qj2a/</link>
      <pubDate>Wed, 26 Mar 2025 20:28:24 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/ysld_6qj2a/</guid>
      <description>&lt;p&gt;下载蛋白质，去除水分子，加H，去除配体，去除副链&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
# %%
import pymol

# %%
# 使用 fetch 指令获取蛋白质结构，这里以 4FAA 为例
pdb_id = &amp;#39;4FAA&amp;#39;
pymol.cmd.fetch(pdb_id)

# 去除水分子
pymol.cmd.remove(&amp;#39;solvent&amp;#39;)

# 加 H（氢原子）
pymol.cmd.h_add()

# 选择配体（这里假设配体残基名为 NAG）
pymol.cmd.select(&amp;#39;ligand&amp;#39;, &amp;#39;resn NAG&amp;#39;)

# 去除配体
pymol.cmd.remove(&amp;#39;ligand&amp;#39;)

# 显示链 A 的信息
pymol.cmd.iterate(&amp;#39;chain A&amp;#39;, &amp;#39;print(resi, resn)&amp;#39;)

# 去除副链（只保留主链）
pymol.cmd.remove(&amp;#39;sidechain&amp;#39;)

# 导出结果为 PDB 文件
output_file = f&amp;#39;{pdb_id}.pymol.pdb&amp;#39;
pymol.cmd.save(output_file)

# 退出 PyMOL
pymol.cmd.quit()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>问卷星自动填写脚本</title>
      <link>https://juiceright.xyz/old/posts/trgcxiotbs/</link>
      <pubDate>Sun, 23 Mar 2025 18:17:36 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/trgcxiotbs/</guid>
      <description>&lt;p&gt;2025年3月23日测试批量填写80份正常。&lt;/p&gt;
&lt;p&gt;需要模拟鼠标操作防止被识别机器人&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import re
from playwright.async_api import Playwright, async_playwright
#from playwright.sync_api import Playwright, sync_playwright, expect
import random

import asyncio
import time
def random_int(min=2, max=4):
    random.seed(time.time())    
    return str(random.randint(min, max))

async def mouse_random_move(page):
    # 模拟鼠标随机平滑移动
    for i in range(5):
        await page.mouse.move(random.randint(0, 1000), random.randint(0, 1000))
        await asyncio.sleep(0.1)
    # 模拟鼠标随机停留
    #time.sleep(random.randint(0,1))
    # 鼠标滚轮

async def run(browser) -&amp;gt; None:
    
    context = await browser.new_context()
    page = await context.new_page()
    await page.goto(&amp;#34;https://www.wjx.cn/vm/Q0x3Wuq.aspx&amp;#34;)
    await page.get_by_text(&amp;#34;男&amp;#34;).click()
    await page.get_by_text(&amp;#34;大三&amp;#34;).click()
    await page.get_by_text(&amp;#34;1000-&amp;#34;).click()
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^全部来自家庭部分来自家庭，部分靠自己赚取全部靠自己赚取$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^300以下300-600600-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^无1-200200-500500以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^实体店网购$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^100以下100-500500-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(3).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div&amp;#34;).filter(has_text=re.compile(r&amp;#34;^无200以下200-500500-10001000以上$&amp;#34;)).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await page.locator(&amp;#34;#div10&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div11&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div12&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div13&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div14&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div15&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div16&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(2).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div17&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(2) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(5) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;div:nth-child(7) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div19&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(3).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div20&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).nth(1).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div20&amp;#34;).get_by_role(&amp;#34;link&amp;#34;).first.click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div21 &amp;gt; .ui-controlgroup &amp;gt; div:nth-child(2) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await mouse_random_move(page)
    await page.locator(&amp;#34;#div21 &amp;gt; .ui-controlgroup &amp;gt; div:nth-child(4) &amp;gt; .jqcheckwrapper &amp;gt; .jqcheck&amp;#34;).click()
    await page.get_by_text(&amp;#34;提交&amp;#34;).click()
    await page.wait_for_function(&amp;#34;window.location.href !== &amp;#39;https://www.wjx.cn/vm/Q0x3Wuq.aspx&amp;#39;&amp;#34;)
    await page.wait_for_timeout(3000)
    await page.close()
    await context.close()

async def main() -&amp;gt; None:
    async with async_playwright() as p:
        browser = await  p.chromium.launch(headless=True)
        tasks = []
        for i in range(6):
            tasks.append(run(browser))
        titles=await asyncio.gather(*tasks)
        for title in titles:  
            print(title) 
        await browser.close()
        
if __name__ == &amp;#34;__main__&amp;#34;:
    asyncio.run(main())
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>python 利用curl将全部网卡适配器登录STU校园网</title>
      <link>https://juiceright.xyz/old/posts/byprsldhih/</link>
      <pubDate>Fri, 14 Mar 2025 20:49:01 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/byprsldhih/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import netifaces
import os
# 获取所有网络接口
interfaces = netifaces.interfaces()

for iface in interfaces:
    # 获取接口的地址信息
    addresses = netifaces.ifaddresses(iface)
    # 提取 IPv4 地址
    if netifaces.AF_INET in addresses:
        for addr_info in addresses[netifaces.AF_INET]:
            ip = addr_info.get(&amp;#39;addr&amp;#39;)
            if ip:
                print(f&amp;#34;适配器 {iface} 的IP地址: {ip}&amp;#34;)
                os.system(&amp;#39;curl --data &amp;#34;opr=pwdLogin&amp;amp;userName=账号&amp;amp;pwd=密码&amp;amp;rememberPwd=1&amp;#34; http://1.1.1.2/ac_portal/login.php  --interface &amp;#39; + ip)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>playwright自动登录STU WebVPN</title>
      <link>https://juiceright.xyz/old/posts/st6eftek36/</link>
      <pubDate>Tue, 11 Mar 2025 09:55:00 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/st6eftek36/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
import re
from playwright.sync_api import Playwright, sync_playwright, expect
import time
import os

import hmac
import hashlib

def totp(key, t, digits=6):
    step = 30
    t = int(t / step)
    key = key.encode()
    counter = t.to_bytes(8, &amp;#39;big&amp;#39;)
    h = hmac.new(key, counter, hashlib.sha1).digest()
    offset = h[-1] &amp;amp; 0x0f
    truncated = h[offset:offset + 4]
    code = int.from_bytes(truncated, &amp;#39;big&amp;#39;) &amp;amp; 0x7fffffff
    code = str(code % 10 ** digits).zfill(digits)
    return code

# %%


def run(playwright: Playwright) -&amp;gt; None:
    browser = playwright.chromium.launch(headless=True)
    context = browser.new_context()
    page = context.new_page()
    page.goto(&amp;#34;https://webvpn.stu.edu.cn/portal/#!/login&amp;#34;)
    page.locator(&amp;#34;#Calc input[type=\&amp;#34;text\&amp;#34;]&amp;#34;).fill(&amp;#34;校园网账号&amp;#34;)
    page.locator(&amp;#34;#loginPwd&amp;#34;).click()
    page.locator(&amp;#34;#loginPwd&amp;#34;).fill(&amp;#34;校园网密码&amp;#34;)
    page.locator(&amp;#34;span&amp;#34;).filter(has_text=&amp;#34;我已阅读并同意&amp;#34;).locator(&amp;#34;div&amp;#34;).first.click()
    page.get_by_role(&amp;#34;button&amp;#34;, name=&amp;#34;登录&amp;#34;).click()
    page.locator(&amp;#34;#app_dialog_container&amp;#34;).get_by_role(&amp;#34;textbox&amp;#34;).fill(str(totp(&amp;#34;填写你的TOTP密钥&amp;#34;, time.time())))
    page.get_by_role(&amp;#34;button&amp;#34;, name=&amp;#34;确定&amp;#34;).click()
    # ---------------------
    # 获取cookie值
    cookies = page.context.cookies()
    for cookie in cookies:
        print(f&amp;#34;{cookie[&amp;#39;name&amp;#39;]}: {cookie[&amp;#39;value&amp;#39;]}&amp;#34;)
        if cookie[&amp;#39;name&amp;#39;] == &amp;#34;TWFID&amp;#34;:
            TWFID = cookie[&amp;#39;value&amp;#39;]
    
    
    url=&amp;#34;https://webvpn.stu.edu.cn/portal/shortcut.html?twfid=&amp;#34;+TWFID+&amp;#34;&amp;amp;url=http://bilibili-com-s.webvpn.stu.edu.cn%3A8118&amp;#34;
    os.system(&amp;#39;start msedge &amp;#34;&amp;#39;+url+&amp;#39;&amp;#34;&amp;#39;)
    # ---------------------
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)

    
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ECDSA实例</title>
      <link>https://juiceright.xyz/old/posts/22bskm0nwq/</link>
      <pubDate>Tue, 11 Mar 2025 01:05:02 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/22bskm0nwq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
import os
import ecdsa

# 生成私钥和公钥
def generate_keys():
    # 使用secp256k1曲线生成密钥对
    sk = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
    vk = sk.get_verifying_key()
    return sk, vk

# 对消息进行签名
def sign_message(private_key, message):
    return private_key.sign(message)

# 验证签名
def verify_signature(public_key, message, signature):
    return public_key.verify(signature, message)

# %%
private_key, public_key = generate_keys()
# 简单消息
message = b&amp;#34;Hello, ECDSA!&amp;#34;

# 签名消息
signature = sign_message(private_key, message)
print(f&amp;#34;Signature: {signature.hex()}&amp;#34;)


# %% 
sig=&amp;#39;adee313bebf78c1bd4a9719e0ad9aa871ff8195788ad2d7510f35e1ef0ce00a6cbfea518e4ea1716a729c7313a52da8b0c57ff0e0f97251ea604beef3890f699&amp;#39;
message = b&amp;#34;Hello, ECDSA!&amp;#34;
signature = bytes.fromhex(sig)
print(verify_signature(public_key, message, signature))   #验证签名
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>汕头大学SSO 单点登录接入实例</title>
      <link>https://juiceright.xyz/old/posts/40qvh8raw6/</link>
      <pubDate>Tue, 11 Mar 2025 01:00:18 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/40qvh8raw6/</guid>
      <description>&lt;p&gt;Single Sign On System&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os
url=&amp;#34;https://sso.stu.edu.cn/login?service=http://localhost:8080&amp;#34;
os.system(&amp;#39;start msedge &amp;#34;&amp;#39;+url+&amp;#39;&amp;#34;&amp;#39;)

import http.server
import socketserver
import urllib.parse
import threading
import requests
import xml.etree.ElementTree as ET
import warnings
warnings.filterwarnings(&amp;#34;ignore&amp;#34;)

# 定义全局变量存储ticket
ticket = None
username = None
# 自定义请求处理类
class MyHandler(http.server.SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # 重写方法，不执行任何操作

    def do_GET(self):
        global ticket, httpd, username
        # 解析请求路径的参数
        parsed_path = urllib.parse.urlparse(self.path)
        query_params = urllib.parse.parse_qs(parsed_path.query)
        
        # 检查是否存在ticket参数
        if &amp;#39;ticket&amp;#39; in query_params:
            ticket = query_params[&amp;#39;ticket&amp;#39;][0]
        
        # 发送响应
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b&amp;#34;Ticket received...&amp;#34;)
        vurl=&amp;#34;https://sso.stu.edu.cn/serviceValidate?service=http://localhost:8080&amp;amp;ticket=&amp;#34;+ticket
        headers={&amp;#39;Connection&amp;#39;:&amp;#39;close&amp;#39;}
        requests.adapters.DEFAULT_RETRIES = 5
        response = requests.get(vurl, headers=headers, verify=False)
        root = ET.fromstring(response.text)
        if root[0].tag.endswith(&amp;#39;authenticationSuccess&amp;#39;):
            print(&amp;#39;Login success, you can close the browser now 登陆成功，您可以关闭浏览器了&amp;#39;)
            print(&amp;#39;username:&amp;#39;, root[0][0].text)
            username = root[0][0].text
            response.close()
            threading.Thread(target=httpd.shutdown).start()
        else:
            print(&amp;#39;Login failed, please try again 登陆失败，请重试&amp;#39;)
            print(&amp;#39;error:&amp;#39;, root[0][0].text)
        # 关闭服务器
# 启动服务器
def run_server():
    global httpd
    port = 8080
    handler = MyHandler
    with socketserver.TCPServer((&amp;#34;&amp;#34;, port), handler) as httpd:
        print(f&amp;#34;Verifying login at https://sso.stu.edu.cn/login?service=http://localhost:8080&amp;#34;)
        httpd.serve_forever()
run_server()


Users =[&amp;#39;用户名&amp;#39;]

if username in Users:
    print(&amp;#39;Login success, welcome to use this script 登陆成功，欢迎使用本脚本&amp;#39;)
else:
    print(&amp;#39;No permission to use this script 没有权限使用本脚本&amp;#39;)
    os.system(&amp;#39;pause&amp;#39;)
    exit()
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>雨课堂习题监控</title>
      <link>https://juiceright.xyz/old/posts/pbdbfbga9g/</link>
      <pubDate>Tue, 11 Mar 2025 00:41:06 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/pbdbfbga9g/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;原理：雨课堂每次切换PPT时url也会跟着改变。在检测到ppt切换后，获取ppt的图片，并且进行OCR检测，如果出现‘单选’、‘多选’、‘判断’、‘填空’、‘投票’等词汇，就认定该ppt是习题，就会发出警告提醒。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用前需要配置state.json保存登录记录。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import asyncio
from playwright.async_api import async_playwright
import requests
import threading
import winsound
from plyer import notification
import easyocr
url=&amp;#34;&amp;#34;
# 初始化 EasyOCR
reader = easyocr.Reader([&amp;#39;ch_sim&amp;#39;, &amp;#39;en&amp;#39;])

async def notice_ti(page):
    # 尝试查找图片元素
    elementimg = await page.query_selector_all(&amp;#39;//*[@id=&amp;#34;app&amp;#34;]/section/section[1]/section[2]/section/section/section/section[1]/section/div/section/section/img&amp;#39;)
    if len(elementimg) == 0:
        elementimg = await page.query_selector_all(&amp;#39;//*[@id=&amp;#34;app&amp;#34;]/section/section[1]/section[2]/section/section/section/section[1]/section/section/section/section/img&amp;#39;)

    # 发送新页面通知
    notification.notify(title=&amp;#39;新的一页&amp;#39;, message=&amp;#39;新的一页&amp;#39;, app_icon=None, timeout=0.5)

    if elementimg:
        # 获取图片地址
        img_url = await elementimg[0].get_attribute(&amp;#39;src&amp;#39;)
        # 直接下载图片
        tmp = requests.get(img_url)
        with open(&amp;#39;tmp.png&amp;#39;, &amp;#39;wb&amp;#39;) as f:
            f.write(tmp.content)

        # 使用 EasyOCR 识别图片文字
        result = reader.readtext(&amp;#39;tmp.png&amp;#39;)
        # 如果 result 中含有‘单选’、‘多选’、‘判断’、‘填空’、‘投票’、‘问答’、‘作业’、‘讨论’、‘实验’、‘课件’、‘课程’、‘提交’等关键词，就发送通知
        keywords = [&amp;#39;单选&amp;#39;, &amp;#39;多选&amp;#39;, &amp;#39;判断&amp;#39;, &amp;#39;填空&amp;#39;, &amp;#39;投票&amp;#39;, &amp;#39;问答&amp;#39;, &amp;#39;作业&amp;#39;, &amp;#39;讨论&amp;#39;, &amp;#39;实验&amp;#39;, &amp;#39;提交&amp;#39;]
        #keywords = [&amp;#39;电解&amp;#39;]
        if any(x in str(result) for x in keywords):
            print(img_url)
            threading.Thread(target=lambda: winsound.Beep(440, 3000)).start()
            notification.notify(title=&amp;#39;有题！&amp;#39;, message=&amp;#39;有题！&amp;#39;, app_icon=None, timeout=0.5)
            # ai(result)
            # clear_page()

async def main():
    async with async_playwright() as p:
        # 配置浏览器选项
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context(storage_state=&amp;#39;state.json&amp;#39;)
        page = await context.new_page()
        # 打开指定页面
        await page.goto(url)

        current_url = page.url
        while True:
            # 等待 URL 变化
            await page.wait_for_url(lambda url: url != current_url, timeout=10000000)
            current_url = page.url
            await notice_ti(page)
            #await print(&amp;#34;已到达新页面&amp;#34;)

if __name__ == &amp;#34;__main__&amp;#34;:
    url=input(&amp;#34;请输入网址：&amp;#34;)
    asyncio.run(main())
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
