<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Juiceright</title>
    <link>https://juiceright.xyz/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Juiceright</description>
    <generator>Hugo -- 0.154.1</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Dec 2025 10:18:33 +0000</lastBuildDate>
    <atom:link href="https://juiceright.xyz/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>zkw线段树</title>
      <link>https://juiceright.xyz/old/posts/uljgqekoo3/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:55 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/uljgqekoo3/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int d[500000*4],n,m=1;


inline void build(int n){
	while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;
    for(int i=m+1;i&amp;lt;=m+n;i++) cin&amp;gt;&amp;gt;d[i];
    for(int i=m-1;i;--i) d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1]; 
}  

void chg(int x,int v){
    d[x=m+x]+=v;
    while(x) d[x&amp;gt;&amp;gt;=1]=d[x&amp;lt;&amp;lt;1]+d[x&amp;lt;&amp;lt;1|1];
}  

int add(int x,int v){
	for(int i=x+m;i;i&amp;gt;&amp;gt;=1)d[i]+=v;
}
int ask(int l,int r){
int ans=0;
for(l=m+l-1,r=m+r+1 ; l^r^1 ; l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1){
	if(~l&amp;amp;1)ans+=d[l^1];
if(r&amp;amp;1)ans+=d[r^1];
}
return ans;
}
void debug(){
	for(int i=m+1;i&amp;lt;=m+n;i++)cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;
	cout&amp;lt;&amp;lt;m&amp;lt;&amp;lt;endl;
	
}
int main(){
int q;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;
build(n);
while(q--){
	int op,a,b;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(op==1)add(a,b);
	else cout&amp;lt;&amp;lt;ask(a,b)&amp;lt;&amp;lt;endl;
}


} 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ST表</title>
      <link>https://juiceright.xyz/old/posts/6jfataceqh/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:40 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/6jfataceqh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int f[2000010][24],n;
int get(int x,int y){
	int k=log(y-x+1)/log(2);
	return max(f[x][k],f[y-(1&amp;lt;&amp;lt;k)+1][k]);
}
int main(){
	int i,j,m,t,k;
	scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;n,&amp;amp;m);
	for(i=1;i&amp;lt;=n;i++)
	scanf(&amp;#34;%d&amp;#34;,&amp;amp;f[i][0]);
	int x=log(n)/log(2)+1;
	for(int j=1;j&amp;lt;x;j++)
	for(int i=1;i&amp;lt;=n-(1&amp;lt;&amp;lt;j)+1;i++)
	f[i][j]=max(f[i][j-1],f[i+(1&amp;lt;&amp;lt;(j-1))][j-1]);
	while(m--){
		int a,b;
		scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		printf(&amp;#34;%d\n&amp;#34;,get(a,b));
		
		
	}

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SPFA算法</title>
      <link>https://juiceright.xyz/old/posts/ldovg2gc2p/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:27 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/ldovg2gc2p/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const long long   N=100010,M=200011;
long long   head[N],ver[M],edge[M],Next[M],d[N];
long long   n,m,tot=0;
queue&amp;lt;long long &amp;gt;q;
bool v[N];
void add(long long   x,long long   y,long long   z){
	ver[++tot]=y;edge[tot]=z;Next[tot]=head[x];
	head[x]=tot;
}
int main(){
long long   i,j,n,m,a,b,c,s;
scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);
while(m--){
scanf(&amp;#34;%lld %lld %lld&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;c);
add(a,b,c);
//	add(b,a,c);
}
memset(d,0x3f,sizeof(d));
memset(v,0,sizeof(v));
d[s]=0;
v[s]=1;
q.push(1);
while(q.size())
{
	long long   x=q.front();
	q.pop();
	v[x]=0;
	for(long long  i=head[x];i;i=Next[i])
	{long long   y=ver[i],z=edge[i];
	if(d[y]&amp;gt;d[x]+z){
		d[y]=d[x]+z;
		if(!v[y])
		{
			q.push(y);
			v[y]=1;
			
		}
	}
	}
	
	
}


for(i=1;i&amp;lt;=n;i++)
cout&amp;lt;&amp;lt;d[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;;


}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim算法</title>
      <link>https://juiceright.xyz/old/posts/f481dm04tj/</link>
      <pubDate>Mon, 10 Mar 2025 13:28:15 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/f481dm04tj/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef int ll;

ll d[5010],mp[5010][5010];
bool v[5010];
ll i,j,n,m,t,k;

int main() {
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	memset(mp,0x3f,sizeof(mp));
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	ll a,b,c;

	for(i=1; i&amp;lt;=m; i++) {
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;

		mp[a][b]=min(mp[a][b],c);

		mp[b][a]=mp[a][b];

	}

	d[1]=0;

	for(i=1; i&amp;lt;n; i++) {
		ll x=0;
		for(j=1; j&amp;lt;=n; j++)

			if(!v[j]&amp;amp;&amp;amp;(x==0||d[j]&amp;lt;d[x]))x=j;

		v[x]=1;
		for(j=1; j&amp;lt;=n; j++)

			if(!v[j])d[j]=min(d[j],mp[x][j]);

	}

	ll ans=0;
	for(i=2; i&amp;lt;=n; i++)
		ans+=d[i];
	
	if(ans&amp;gt;99999999)cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;
	else cout&amp;lt;&amp;lt;ans;
	
	
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Prim堆优化版</title>
      <link>https://juiceright.xyz/old/posts/ibw-bmba9u/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:52 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/ibw-bmba9u/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
priority_queue&amp;lt;pair&amp;lt;long long,long long&amp;gt; &amp;gt;q;
vector&amp;lt;long long&amp;gt;ver[5010],edge[5010];
bool v[5010];
long long d[5010];
long long n,m;
void add(long long x,long long y,long long z){
	ver[x].push_back(y);edge[x].push_back(z);
}
void init(){
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	for(long long i=1;i&amp;lt;=m;i++){
		long long a,b,c;
		cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
		add(a,b,c);add(b,a,c);
	}
}

void work(){
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	long long ans=0;
	d[1]=0;
	q.push(make_pair(0,1));
	int cnt=0;
	while(q.size()){
		long long x=q.top().second;
		q.pop();
		if(v[x])continue;
		v[x]=1;
		cnt++;
		for(int i=ver[x].size()-1;i&amp;gt;=0;i--){
		
			int y=ver[x][i],z=edge[x][i];
			if(!v[y] &amp;amp;&amp;amp;(z&amp;lt;d[y])){
				d[y]=z;
				q.push(make_pair(-d[y],y));
			}
		}
		
		
	}
for(int i=2;i&amp;lt;=n;i++)ans+=d[i];
if(cnt==n)cout&amp;lt;&amp;lt;ans;
else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;


}

int main(){
init();
work();

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LCA算法</title>
      <link>https://juiceright.xyz/old/posts/5ipfk_eghq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:39 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/5ipfk_eghq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// luogu-judger-enable-o2
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int ver[2*500000],nex[2*500000],head[2*500000],d[2*500000],p[2*500000][23],tot;
void add(int x,int y){
	ver[++tot]=y;nex[tot]=head[x];head[x]=tot;
}
int read(){
	int x=0;
	char ch;
	while(ch&amp;lt;&amp;#39;0&amp;#39;||ch&amp;gt;&amp;#39;9&amp;#39;)ch=getchar();
	while(ch&amp;gt;&amp;#39;0&amp;#39;&amp;amp;&amp;amp;ch&amp;lt;&amp;#39;9&amp;#39;){
		x=x*10+ch-&amp;#39;0&amp;#39;;
		ch=getchar();
	}
	return x;
}
void dfs(int x,int fa){
	d[x]=d[fa]+1;
	p[x][0]=fa;
	for(int i=1;(1&amp;lt;&amp;lt;i)&amp;lt;=d[x];i++)
	p[x][i]=p[p[x][i-1]][i-1];
	for(int i=head[x];i;i=nex[i]){
		if(ver[i]!=fa)
		dfs(ver[i],x);	
	}
}
int lca(int a,int b){
	if(d[a]&amp;gt;d[b])swap(a,b);
	for(int i=20;i&amp;gt;=0;i--)
	if(d[a]&amp;lt;=d[b]-(1&amp;lt;&amp;lt;i))
	b=p[b][i];
	if(a==b)
	return a;
	for(int i=20;i&amp;gt;=0;i--)
	if(p[a][i]==p[b][i])continue;
	else a=p[a][i],b=p[b][i];
	
	return p[a][0];
}
int main(){
	int i,j,n,m,t,k,s;
	scanf(&amp;#34;%d %d %d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);
	for(int i=1;i&amp;lt;n;i++)
	{
		int a,b;
		scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		add(a,b);
		add(b,a);
	}
	dfs(s,0);
	for(i=1;i&amp;lt;=m;i++)
	{
		int a,b;
	scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;a,&amp;amp;b);
		cout&amp;lt;&amp;lt;lca(a,b)&amp;lt;&amp;lt;endl;
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>匈牙利算法</title>
      <link>https://juiceright.xyz/old/posts/rnbllzkklq/</link>
      <pubDate>Mon, 10 Mar 2025 13:27:28 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/rnbllzkklq/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
bool ver[1001][1001],v[1001];
int d[1001],n,m,e;
bool dfs(int x){
	for(int i=1;i&amp;lt;=m;i++){
	if(ver[x][i]&amp;amp;&amp;amp;!v[i]){
		v[i]=1;
		if(!d[i]||dfs(d[i])){
			d[i]=x;return 1;
		}
		
	}

	}
	return 0;
}
void init(){
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;e;
for(int i=1;i&amp;lt;=e;i++){
	int a,b;
	cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(b&amp;gt;m||a&amp;gt;n)continue;
	ver[a][b]=1;

}
	int ans=0;
	for(int i=1;i&amp;lt;=n;i++){memset(v,0,sizeof(v));
	ans+=dfs(i);
	}
	cout&amp;lt;&amp;lt;ans;
}
int main(){
init();
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>线段树</title>
      <link>https://juiceright.xyz/old/posts/cse8xfl8mp/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:55 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/cse8xfl8mp/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
struct pl{
	long long l,r,v,add,tim;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define v(x) tree[x].v
	#define add(x) tree[x].add
}tree[4*100000];
long long a[100001];
void build(long long p,long long l,long long r){
	l(p)=l;r(p)=r;
	if(l==r){
		v(p)=a[l];return;
	}
	long long mid=(l+r)&amp;gt;&amp;gt;1;
	build(p&amp;lt;&amp;lt;1,l,mid);
	build((p&amp;lt;&amp;lt;1)+1,mid+1,r);
	v(p)=v(p*2)+v(p*2+1);
}
void spread(long long p){
	if(add(p)==0)return;
	v(p*2)+=add(p)*(r(p*2)-l(p*2)+1);
	v(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);
	add(p*2)+=add(p);
	add(p*2+1)+=add(p);
	add(p)=0;
}
void chg(long long p,long long l,long long r,long long d){
	if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p)){
		v(p)+=d*(r(p)-l(p)+1);
		add(p)+=d;
		return;
	}
	spread(p);
	long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;
	if(l&amp;lt;=mid)chg(p*2,l,r,d);
	if(r&amp;gt;mid)chg(p*2+1,l,r,d);
	v(p)=v(p*2)+v(p*2+1);
}
long long ask(long long p,long long l,long long r){
	if(l&amp;lt;=l(p)&amp;amp;&amp;amp;r&amp;gt;=r(p))return v(p);
	spread(p);
	long long mid=(l(p)+r(p))&amp;gt;&amp;gt;1;
	long long ans=0;
	if(l&amp;lt;=mid)ans+=ask(p*2,l,r);
	if(r&amp;gt;mid)ans+=ask(p*2+1,l,r);
	return ans;
}
int main(){
long long i,j,n,m,t,k;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
for(i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;a[i];
build(1,1,n);
while(m--){
	long long op,l,r,k;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;l&amp;gt;&amp;gt;r;
	if(op==1){
		cin&amp;gt;&amp;gt;k;
		chg(1,l,r,k);
	}else cout&amp;lt;&amp;lt;ask(1,l,r)&amp;lt;&amp;lt;endl;	
}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>树状数组</title>
      <link>https://juiceright.xyz/old/posts/hl1binzfbh/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:42 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/hl1binzfbh/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
long long c[500001];
	long long i,j,n,m,t,k;
long long lb(long long x)
{return x&amp;amp;(-x);
}
long long get(long long x)
{
	long long ans=0;
	for(;x;x-=lb(x))
	ans+=c[x];
	return ans;
}
void add(long long x,long long y){
	for(long long i=x;i&amp;lt;=n;i+=lb(i))
	c[i]+=y;
	
}

int main(){

	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
	for(i=1;i&amp;lt;=n;i++)
	{scanf(&amp;#34;%lld&amp;#34;,&amp;amp;t);
	add(i,t);
	}
	while(m--){
		cin&amp;gt;&amp;gt;t;
		if(t==1){
			cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;
			add(j,k);
		}
		else {
			
			cin&amp;gt;&amp;gt;j&amp;gt;&amp;gt;k;
			cout&amp;lt;&amp;lt;get(k)-get(j-1)&amp;lt;&amp;lt;endl;
		}
		
	}
	
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>kruskal算法（克鲁斯卡尔算法）</title>
      <link>https://juiceright.xyz/old/posts/y1ekvamzmi/</link>
      <pubDate>Mon, 10 Mar 2025 13:26:19 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/y1ekvamzmi/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
using namespace std;
ll fa[5010];
ll get(ll x) {
	return x==fa[x]?x:fa[x]=get(fa[x]);
}
void mrg(ll a,ll b) {
fa[get(a)]=get(b);
}
struct pl{
	ll x,y,z;
	bool operator&amp;lt;(const pl &amp;amp;a){
	return z&amp;lt;a.z;
	}
}mp[200001];
int main() {
ll i,j,n,m,t=0,k=0;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
for(i=1;i&amp;lt;=m;i++)
{
	cin&amp;gt;&amp;gt;mp[i].x&amp;gt;&amp;gt;mp[i].y&amp;gt;&amp;gt;mp[i].z;
}
sort(mp+1,mp+1+m);
for(i=1;i&amp;lt;=n;i++)fa[i]=i;
for(i=1;i&amp;lt;=m&amp;amp;&amp;amp;t&amp;lt;n;i++){
	if(get(mp[i].x)!=get(mp[i].y))mrg(mp[i].x,mp[i].y),t++,k+=mp[i].z;	
}
if(t==n-1)
cout&amp;lt;&amp;lt;k;
else cout&amp;lt;&amp;lt;&amp;#34;orz&amp;#34;;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>带lazy标记的zkw线段树</title>
      <link>https://juiceright.xyz/old/posts/wwlgapb2j1/</link>
      <pubDate>Mon, 10 Mar 2025 13:25:58 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/wwlgapb2j1/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
long long d[500000&amp;lt;&amp;lt;2],laz[500000&amp;lt;&amp;lt;2],n,m=1;;
void build(){
	while(m&amp;lt;=n)m&amp;lt;&amp;lt;=1;
	for(long long i=m+1;i&amp;lt;=m+n;i++)cin&amp;gt;&amp;gt;d[i];
	for(long long i=m-1;i&amp;gt;=1;i--)d[i]=d[i&amp;lt;&amp;lt;1]+d[i&amp;lt;&amp;lt;1|1];
}
long long get(long long x,long long y){
	long long ans=0,lc=0,rc=0,cnt=1;//cnt=1
	for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){
		if(laz[x])ans+=laz[x]*lc;
		if(laz[y])ans+=laz[y]*rc;
		if(~x&amp;amp;1)ans+=d[x^1],lc+=cnt;
		if(y&amp;amp;1)ans+=d[y^1],rc+=cnt;
	}
	
		for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)ans+=laz[x]*lc,ans+=laz[y]*rc;
	return ans;
}
void add(long long x,long long y,long long v){
	long long ans=0,lc=0,rc=0,cnt=1;//cnt=1
	for(x+=m-1,y+=m+1; x^y^1; x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1,cnt&amp;lt;&amp;lt;=1){
		d[x]+=v*lc;d[y]+=v*rc;
		if(~x&amp;amp;1) laz[x^1]+=v,d[x^1]+=v*cnt,lc+=cnt;
		if(y&amp;amp;1)  laz[y^1]+=v,d[y^1]+=v*cnt,rc+=cnt;		

	}
for(;x;x&amp;gt;&amp;gt;=1,y&amp;gt;&amp;gt;=1)d[x]+=v*lc,d[y]+=v*rc;
}
int main(){
long long q;
cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;
build();
while(q--){
	long long a,b,op,c;
	cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
	if(op==1){
		cin&amp;gt;&amp;gt;c;
		add(a,b,c);
	}else{
		
		cout&amp;lt;&amp;lt;get(a,b)&amp;lt;&amp;lt;endl;
		
	}
	
	
}




} 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>排序时间复杂度</title>
      <link>https://juiceright.xyz/old/posts/3ilwt_ogfy/</link>
      <pubDate>Mon, 10 Mar 2025 13:21:35 +0000</pubDate>
      <guid>https://juiceright.xyz/old/posts/3ilwt_ogfy/</guid>
      <description>&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;排序方法&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（平均）&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（最坏)&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;时间复杂度（最好)&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;稳定性&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;复杂性&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;直接插入排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;直接选择排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;堆排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;简单&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n2)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;不稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(nlog2n)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;基数排序&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(d(n+r))&lt;/td&gt;
          &lt;td&gt;O(n+r)&lt;/td&gt;
          &lt;td&gt;稳定&lt;/td&gt;
          &lt;td&gt;较复杂&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
  </channel>
</rss>
